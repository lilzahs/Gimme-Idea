const fs = require('fs');
const path = require('path');

// Config paths
const MOCK_FILE_PATH = path.join(__dirname, '../frontend/lib/mock-hackathons.ts');
const OUTPUT_SQL_PATH = path.join(__dirname, '../backend/database/seed_hackathon_data.sql');

// Helper to escape SQL strings
const escapeSql = (str) => {
  if (typeof str !== 'string') return str;
  return str.replace(/'/g, "''"); // Escape single quotes for SQL
};

try {
  // 1. Read Mock File
  console.log(`Reading mock data from: ${MOCK_FILE_PATH}`);
  let fileContent = fs.readFileSync(MOCK_FILE_PATH, 'utf8');

  // 2. Extract the Array (Hack: avoiding full TS compilation for a simple script)
  // We look for "export const HACKATHONS_MOCK_DATA = [" and the end of the array
  const startIndex = fileContent.indexOf('[');
  const endIndex = fileContent.lastIndexOf('];') + 1;
  
  if (startIndex === -1 || endIndex === -1) {
    throw new Error('Could not find HACKATHONS_MOCK_DATA array in the file.');
  }

  // Evaluate the array string to a JS object
  // Note: This relies on the mock file being relatively simple JS/JSON structure
  const arrayString = fileContent.substring(startIndex, endIndex);
  
  // Safe-ish eval (assuming trusted local file)
  // We need to handle 'date-fns' imports or just treat the file as text if it has imports
  // To be safe, let's use a stricter parsing or expect the user to keep the mock file simple.
  // For now, let's try to parse it.
  
  // Quick fix for the script: Remove typescript types if any
  let cleanString = arrayString.replace(/: \w+(\[\])?/g, ''); 
  
  const hackathons = eval(cleanString); 

  console.log(`Found ${hackathons.length} hackathon(s). Generating SQL...`);

  // 3. Generate SQL
  let sqlContent = `-- SEED DATA GENERATED FROM MOCK FILE
-- DO NOT EDIT THIS FILE DIRECTLY. EDIT frontend/lib/mock-hackathons.ts AND RUN 'node scripts/generate-seed.js'

-- 0. Ensure Columns Exist
ALTER TABLE hackathons ADD COLUMN IF NOT EXISTS prizes JSONB DEFAULT '[]'::jsonb;
ALTER TABLE hackathons ADD COLUMN IF NOT EXISTS tasks JSONB DEFAULT '[]'::jsonb;
ALTER TABLE hackathons ADD COLUMN IF NOT EXISTS tracks JSONB DEFAULT '[]'::jsonb;
ALTER TABLE hackathons ADD COLUMN IF NOT EXISTS timeline JSONB DEFAULT '[]'::jsonb;
ALTER TABLE hackathons ADD COLUMN IF NOT EXISTS resources JSONB DEFAULT '[]'::jsonb;
ALTER TABLE hackathons ADD COLUMN IF NOT EXISTS config JSONB DEFAULT '{}'::jsonb;

`;

  hackathons.forEach(h => {
    // Determine status from date logic or use mock status
    const slug = h.id; // Use ID as slug
    
    // Convert Dates to ISO if they aren't
    const startDate = new Date(h.timeline[0]?.startDate).toISOString();
    const endDate = h.timeline[h.timeline.length -1]?.endDate 
        ? new Date(h.timeline[h.timeline.length -1]?.endDate).toISOString()
        : new Date(new Date(startDate).getTime() + 30*24*60*60*1000).toISOString();

    const timelineJson = JSON.stringify(h.timeline);
    const tracksJson = JSON.stringify(h.tracks);
    const prizesJson = JSON.stringify(h.prizes);
    const tasksJson = JSON.stringify(h.tasks);
    const resourcesJson = JSON.stringify(h.resources);
    
    // Construct Config JSON (Tabs + others)
    const configJson = JSON.stringify({ tabs: h.tabs });

    // HACKATHON INSERT
    sqlContent += `
-- 1. Upsert Hackathon: ${h.title}
INSERT INTO hackathons (
  slug, title, description, start_date, end_date, status, prize_pool, image_url, 
  timeline, tracks, prizes, tasks, resources, config
) VALUES (
  '${escapeSql(slug)}',
  '${escapeSql(h.title)}',
  '${escapeSql(h.description)}',
  '${startDate}',
  '${endDate}',
  '${h.status}',
  '${escapeSql(h.prizePool)}',
  '${escapeSql(h.image_url)}',
  '${timelineJson}'::jsonb,
  '${tracksJson}'::jsonb,
  '${prizesJson}'::jsonb,
  '${tasksJson}'::jsonb,
  '${resourcesJson}'::jsonb,
  '${configJson}'::jsonb
)
ON CONFLICT (slug) DO UPDATE SET
  title = EXCLUDED.title,
  description = EXCLUDED.description,
  start_date = EXCLUDED.start_date,
  end_date = EXCLUDED.end_date,
  status = EXCLUDED.status,
  prize_pool = EXCLUDED.prize_pool,
  image_url = EXCLUDED.image_url,
  timeline = EXCLUDED.timeline,
  tracks = EXCLUDED.tracks,
  prizes = EXCLUDED.prizes,
  tasks = EXCLUDED.tasks,
  resources = EXCLUDED.resources,
  config = EXCLUDED.config;
`;

    // ANNOUNCEMENTS INSERT
    if (h.announcements && h.announcements.length > 0) {
        sqlContent += `
-- 2. Insert Announcements for ${slug}
DO $$
DECLARE
  h_id UUID;
BEGIN
  SELECT id INTO h_id FROM hackathons WHERE slug = '${escapeSql(slug)}';
  DELETE FROM hackathon_announcements WHERE hackathon_id = h_id;
  INSERT INTO hackathon_announcements (hackathon_id, content, type, published_at, effect, widget) VALUES
`;
        const values = h.announcements.map(a => {
            const date = new Date(a.date).toISOString();
            const widget = a.config?.widget ? `'${JSON.stringify(a.config.widget)}'` : 'NULL';
            const effect = a.config?.effect ? `'${a.config.effect}'` : 'NULL';
            return `  (h_id, '${escapeSql(a.message)}', '${a.type}', '${date}', ${effect}, ${widget})`;
        }).join(',\n');

        sqlContent += values + ';\nEND $$;\n\n';
    }
  });

  // 4. Write File
  fs.writeFileSync(OUTPUT_SQL_PATH, sqlContent);
  console.log(`\n‚úÖ Success! SQL seed generated at: ${OUTPUT_SQL_PATH}`);
  console.log('üëâ Now run this SQL file in Supabase Editor to sync your data.');

} catch (err) {
  console.error('‚ùå Error generating SQL:', err.message);
  console.error(err);
}
